}
# we're using random walk on the transformed space and evaluating everything
# in terms of the untransformed parameters. That's why we have the log
# Jacobians in this expression
logQEv <- function(oldAlpha, oldBeta, oldPhi, targetAlpha, targetBeta, targetPhi){
dnorm(x = transAlpha(targetAlpha),
mean = transAlpha(oldAlpha),
sd = sqrt(alphaQCovMat),
log = TRUE) - log(targetAlpha) +
dmvnorm(x = targetBeta,
mean = oldBeta,
sigma = betaQCovMat,
log = TRUE) +
dmvnorm(x = targetPhi,
mean = oldPhi,
sigma = phiQCovMat,
log = TRUE)
}
getLogRatio <- function(oldAlpha, oldBeta, oldPhi,
oldApproxLogTerm, propAlpha,
propBeta, propPhi, propApproxLogTerm){
res <- logPrior(alpha = propAlpha, beta = ppropBeta, phi = propPhi) -
logPrior(alpha = oldAlpha, beta = oldBeta, phi = oldPhi)
res <- res + propApproxLogTerm - oldApproxLogTerm
res <- res +
logQEv(oldAlpha = propAlpha,
oldBeta = propBeta,
oldPhi = propPhi) -
logQEv(targetAlpha = oldAlpha,
targetBeta = oldBeta,
targetPhi = oldPhi)
return(res)
}
do1Iter <- function(oldSamp, N){
propParams <- qSim(oldSamp$alphas, oldSamp$betas, oldSamp$phis)
newApproxTerm <- getLogImpSampEst(propParams$alphas, propParams$betas, propParams$phis, N)
logratio <- getLogRatio(oldAlpha = oldSamp$alphas,
oldBeta = oldSamp$betas,
oldPhi = oldSamp$phis,
oldApproxLogTerm = oldSamp$EstLogTerm,
propAlpha = propParams$alphas,
propBeta = propParams$betas,
propPhi = propParams$phis,
propApproxLogTerm = propParams$EstLogTerm)
if(log(runif(1)) < logratio){ # accept!
#cat("current approx thing: ", newApproxTerm)
list(alphas = propParams$alphas,
betas = propParams$betas,
phis = propParams$phis,
EstLogTerm = newApproxTerm)
}else{
#cat("current approx thing: ", oldSamp$EstLogTerm)
oldSamp
}
}
###############################################
# trial run to get approx covariance matrices #
###############################################
N <- 500
startAlpha <- 1
startBeta <- c(1,1,1)
startPhi <- c(1,1,1)
getLogImpSampEst(startAlpha, startBeta, startPhi, N)
startLogTermEst <- getLogImpSampEst(startAlpha, startBeta, y1, sds, N) #TODO make sure this isn't a -Inf
getLogImpSampEst(startAlpha, startBeta, startPhi, N)
library(mmcmc)
??mmcm
??mmcmc
?rhats
detach("package:mmcmc")
detach("package:mmcmc", unload = T)
library(devtools)
install_github("tbrown122387/mmcmc")
library(mmcmc)
library(mmcmc)
getLogImpSampEst(startAlpha, startBeta, startPhi, N)
library(invgamma)
library(matrixStats)
library(MASS) # mvrnorm
library(mmcmc)
?rhats
?remove.packages()
remove.packages("mmcmc")
setwd("~/mmcmc")
load_all()
document()
check())
check()
load_all()
install_github("tbrown122387/mmcmc")
load_all()
load_all()
.rs.restartR()
getwd()
load_all()
??mmcmc
document()
install_github("tbrown122387/mmcmc")
setwd("~/")
load_all()
library(mmcmc)
lsf.str("package:mmcmc")
?logLogisticRegCndtlLike
library(invgamma)
library(matrixStats)
library(MASS) # mvrnorm
library(mmcmc)
# get some data
source("~/pmglm/code/sim_fake_data.r")
numRows <- 100
betas <- c(1, -2, 3)
alpha <- 1
phis <- c(1, 1, 1)
fake_data <- sim_data(nrow = numRows, beta_coeffs = betas, alpha_coeffs = alpha, phi_coeffs = phis)
y <- fake_data$y
X <- fake_data$X
M <- fake_data$M
X[M == 0] <- NA
mis <- is.na(X)
numColsWithMiss <- sum(colSums(mis) != 0)
numMissingEachGroup <- colSums(mis)[colSums(mis) != 0]
# define prior
logPrior <- function(alpha, beta, phi){
logAlphaPrior <- invgamma::dinvgamma(alpha, shape = .001, rate = .001, log = T)
logBetaPrior <- sum(dnorm(betas, 0, 3, log = T))
logPhiPrior <- sum(dnorm(phi, 0, 3, log = T))
logAlphaPrior + logBetaPrior + logPhiPrior
}
# sample q(x_{mis} | x_{obs}, y)
propose_missdata_given_params <- function(y){
list(x2mis = rt(numMissingEachGroup, df = 3))
}
# eval log q(x_{mis} | x_{obs}, y)
logMissingDataProposal <- function(x2mis){
sum(dt(x = x2mis, df = 3, log = T))
}
logCondLikes <- function(xmis, beta){
# insert simulated data into missing data spots
X[is.na(X[,2])] <- xmis
X <- cbind(rep(1,numRows), X)
stopifnot(sum(is.na(X))==0)
linked_means <- as.vector(X %*% as.matrix(beta))
logLogisticRegCndtlLike(y, linked_means)
}
logMissingProbs <- function(M, xmis, phis){
X[is.na(X[,2])] <- xmis
X <- cbind(rep(1,numRows), X)
stopifnot(is.matrix(M))
stopifnot(dim(M)[1] == numRows)
stopifnot(dim(M)[2] == 2)
stopifnot(sum(is.na(X))==0)
linked_means <- as.vector(X %*% as.matrix(phis))
logLogisticRegCndtlLike(M[,2], linked_means)
}
logMissingDataProbs <- function(xmis, alpha){
sum(dnorm(xmis, 0, sd = sqrt(alpha), log = T))
}
# log p(m|y, xmis, xobs, phi) + log p(y|xmis,xobs,beta) + log p(xmis|xobs,alpha) - log q(xmis|xobs,y,alpha,beta)
getOneLogSummand <- function(alpha, beta, phis, y){
Xmis <- propose_missdata_given_params(y)
logLikes <- logCondLikes(Xmis$x2mis, beta)
logpmweights <- logMissingProbs(M, Xmis$x2mis, phis)
logMissXProbs <- logMissingDataProbs(Xmis$x2mis, alpha)
logQs <- logMissingDataProposal(Xmis$x2mis)
sum(logLikes+logpmweights+logMissXProbs-logQs)
}
getLogImpSampEst <- function(alphaVec, betaVec, phiVec, N=100){
# assumes importance distribution is the missing data distribution
samps <- replicate(N, getOneLogSummand(alphaVec, betaVec, phiVec, y))
logSumExp(samps-log(N))
}
# set up the tuning parameters for the proposal
numBetas <- ncol(X) + 1
numAlphas <- 1
numPhis <- numBetas
d <- numBetas + numAlphas + numPhis
alphaQCovMat <- .1 * (2.4^2)/d
betaQCovMat <- .1*diag(numBetas) * (2.4^2)/d
phiQCovMat <- .1*diag(numPhis) * (2.4^2)/d
transAlpha <- function(alpha){
log(alpha)
}
getAlpha <- function(transformedAlpha){
exp(transformedAlpha)
}
# multivariate normal random walk and then transform to original space
qSim <- function(oldAlpha, oldBeta, oldPhi){
# sample alphas
newAlpha <- getAlpha(rnorm(n = 1, mean = transAlpha(oldAlpha), sd = sqrt(alphaQCovMat)))
# sample betas
newBeta <- mvrnorm(n=1,
mu=oldBeta,
Sigma = betaQCovMat)
newPhis <- mvrnorm(n = 1,
mu = oldPhi,
Sigma = phiQCovMat)
# return stuff
list(alphas = newAlpha, betas = newBeta, phis = newPhis)
}
# we're using random walk on the transformed space and evaluating everything
# in terms of the untransformed parameters. That's why we have the log
# Jacobians in this expression
logQEv <- function(oldAlpha, oldBeta, oldPhi, targetAlpha, targetBeta, targetPhi){
dnorm(x = transAlpha(targetAlpha),
mean = transAlpha(oldAlpha),
sd = sqrt(alphaQCovMat),
log = TRUE) - log(targetAlpha) +
dmvnorm(x = targetBeta,
mean = oldBeta,
sigma = betaQCovMat,
log = TRUE) +
dmvnorm(x = targetPhi,
mean = oldPhi,
sigma = phiQCovMat,
log = TRUE)
}
getLogRatio <- function(oldAlpha, oldBeta, oldPhi,
oldApproxLogTerm, propAlpha,
propBeta, propPhi, propApproxLogTerm){
res <- logPrior(alpha = propAlpha, beta = ppropBeta, phi = propPhi) -
logPrior(alpha = oldAlpha, beta = oldBeta, phi = oldPhi)
res <- res + propApproxLogTerm - oldApproxLogTerm
res <- res +
logQEv(oldAlpha = propAlpha,
oldBeta = propBeta,
oldPhi = propPhi) -
logQEv(targetAlpha = oldAlpha,
targetBeta = oldBeta,
targetPhi = oldPhi)
return(res)
}
do1Iter <- function(oldSamp, N){
propParams <- qSim(oldSamp$alphas, oldSamp$betas, oldSamp$phis)
newApproxTerm <- getLogImpSampEst(propParams$alphas, propParams$betas, propParams$phis, N)
logratio <- getLogRatio(oldAlpha = oldSamp$alphas,
oldBeta = oldSamp$betas,
oldPhi = oldSamp$phis,
oldApproxLogTerm = oldSamp$EstLogTerm,
propAlpha = propParams$alphas,
propBeta = propParams$betas,
propPhi = propParams$phis,
propApproxLogTerm = propParams$EstLogTerm)
if(log(runif(1)) < logratio){ # accept!
#cat("current approx thing: ", newApproxTerm)
list(alphas = propParams$alphas,
betas = propParams$betas,
phis = propParams$phis,
EstLogTerm = newApproxTerm)
}else{
#cat("current approx thing: ", oldSamp$EstLogTerm)
oldSamp
}
}
###############################################
# trial run to get approx covariance matrices #
###############################################
N <- 500
startAlpha <- 1
startBeta <- c(1,1,1)
startPhi <- c(1,1,1)
getLogImpSampEst(startAlpha, startBeta, startPhi, N)
samp1 <- list(alphas = startAlpha, betas = startBeta, phis = startPhi, EstLogTerm = startLogTermEst)
startLogTermEst <- getLogImpSampEst(startAlpha, startBeta, startPhi, N)
if(is.infinite(startLogTermEst))
stop("can't start at an impossible event")
samp1 <- list(alphas = startAlpha, betas = startBeta, phis = startPhi, EstLogTerm = startLogTermEst)
paramSamples[[1]] <- samp1  # first guy
trialSamples <- 200
paramSamples <- list(mode='list', length=trialSamples)
paramSamples[[1]] <- samp1  # first guy
for(i in 2:trialSamples){
cat("iter: ", i, "\n")
paramSamples[[i]] <- do1Iter(paramSamples[[i-1]], N, sds)
}
for(i in 2:trialSamples){
cat("iter: ", i, "\n")
paramSamples[[i]] <- do1Iter(paramSamples[[i-1]], N)
}
getLogRatio <- function(oldAlpha, oldBeta, oldPhi,
oldApproxLogTerm, propAlpha,
propBeta, propPhi, propApproxLogTerm){
res <- logPrior(alpha = propAlpha, beta = ppropBeta, phi = propPhi) -
logPrior(alpha = oldAlpha, beta = oldBeta, phi = oldPhi)
res <- res + propApproxLogTerm - oldApproxLogTerm
res <- res +
logQEv(oldAlpha = propAlpha,
oldBeta = propBeta,
oldPhi = propPhi,
targetAlpha = oldAlpha,
targetBeta = oldBeta,
targetPhi = oldPhi) -
logQEv(oldAlpha = oldAlpha,
oldBeta = oldBeta,
oldPhi = oldPhi,
targetAlpha = propAlpha,
targetBeta = propBeta,
targetPhi = propPhi)
return(res)
}
do1Iter <- function(oldSamp, N){
propParams <- qSim(oldSamp$alphas, oldSamp$betas, oldSamp$phis)
newApproxTerm <- getLogImpSampEst(propParams$alphas, propParams$betas, propParams$phis, N)
logratio <- getLogRatio(oldAlpha = oldSamp$alphas,
oldBeta = oldSamp$betas,
oldPhi = oldSamp$phis,
oldApproxLogTerm = oldSamp$EstLogTerm,
propAlpha = propParams$alphas,
propBeta = propParams$betas,
propPhi = propParams$phis,
propApproxLogTerm = propParams$EstLogTerm)
if(log(runif(1)) < logratio){ # accept!
#cat("current approx thing: ", newApproxTerm)
list(alphas = propParams$alphas,
betas = propParams$betas,
phis = propParams$phis,
EstLogTerm = newApproxTerm)
}else{
#cat("current approx thing: ", oldSamp$EstLogTerm)
oldSamp
}
}
###############################################
# trial run to get approx covariance matrices #
###############################################
N <- 500
startAlpha <- 1
startBeta <- c(1,1,1)
startPhi <- c(1,1,1)
startLogTermEst <- getLogImpSampEst(startAlpha, startBeta, startPhi, N)
if(is.infinite(startLogTermEst))
stop("can't start at an impossible event")
samp1 <- list(alphas = startAlpha, betas = startBeta, phis = startPhi, EstLogTerm = startLogTermEst)
trialSamples <- 200
paramSamples <- list(mode='list', length=trialSamples)
paramSamples[[1]] <- samp1  # first guy
for(i in 2:trialSamples){
cat("iter: ", i, "\n")
paramSamples[[i]] <- do1Iter(paramSamples[[i-1]], N)
}
?dmvnorm
??dmvnorm
library(MASS)
?dmvnorm
??dmvnorm
library(mvtnorm)
library(mvtnorm) #dmvnorm
###############################################
# trial run to get approx covariance matrices #
###############################################
N <- 500
startAlpha <- 1
startBeta <- c(1,1,1)
startPhi <- c(1,1,1)
startLogTermEst <- getLogImpSampEst(startAlpha, startBeta, startPhi, N)
if(is.infinite(startLogTermEst))
stop("can't start at an impossible event")
samp1 <- list(alphas = startAlpha, betas = startBeta, phis = startPhi, EstLogTerm = startLogTermEst)
trialSamples <- 200
paramSamples <- list(mode='list', length=trialSamples)
paramSamples[[1]] <- samp1  # first guy
for(i in 2:trialSamples){
cat("iter: ", i, "\n")
paramSamples[[i]] <- do1Iter(paramSamples[[i-1]], N)
}
traceback()
getLogImpSampEst(startAlpha, startBeta, startPhi)
do1Iter <- function(oldSamp, N){
propParams <- qSim(oldSamp$alphas, oldSamp$betas, oldSamp$phis)
newApproxTerm <- getLogImpSampEst(propParams$alphas, propParams$betas, propParams$phis, N)
logratio <- getLogRatio(oldAlpha = oldSamp$alphas,
oldBeta = oldSamp$betas,
oldPhi = oldSamp$phis,
oldApproxLogTerm = oldSamp$EstLogTerm,
propAlpha = propParams$alphas,
propBeta = propParams$betas,
propPhi = propParams$phis,
propApproxLogTerm = newApproxTerm)
if(log(runif(1)) < logratio){ # accept!
#cat("current approx thing: ", newApproxTerm)
list(alphas = propParams$alphas,
betas = propParams$betas,
phis = propParams$phis,
EstLogTerm = newApproxTerm)
}else{
#cat("current approx thing: ", oldSamp$EstLogTerm)
oldSamp
}
}
###############################################
# trial run to get approx covariance matrices #
###############################################
N <- 500
startAlpha <- 1
startBeta <- c(1,1,1)
startPhi <- c(1,1,1)
startLogTermEst <- getLogImpSampEst(startAlpha, startBeta, startPhi, N)
if(is.infinite(startLogTermEst))
stop("can't start at an impossible event")
samp1 <- list(alphas = startAlpha, betas = startBeta, phis = startPhi, EstLogTerm = startLogTermEst)
trialSamples <- 200
paramSamples <- list(mode='list', length=trialSamples)
paramSamples[[1]] <- samp1  # first guy
for(i in 2:trialSamples){
cat("iter: ", i, "\n")
paramSamples[[i]] <- do1Iter(paramSamples[[i-1]], N)
}
\usepackage{tikz}\usetikzlibrary{automata, positioning, arrows}
\begin{document}
install.packages("truncnorm")
?dtruncnorm
library("truncnorm")
?dtruncnorm
x <- seq(0, 20, .01)
plot(x, dtruncnorm(x, 0, Inf, 1, sqrt(.125)), type = "l")
x <- seq(0, 2, .001)
plot(x, dtruncnorm(x, 0, Inf, 1, sqrt(.125)), type = "l")
library(truncnorm)
library(invgamma)
plot(x, dinvgamma(x, shape = 1, rate = 1), type = "l")
x <- seq(0, 10, .001)
plot(x, dinvgamma(x, shape = 1, rate = 1), type = "l")
library(mmcmc)
elicitInvGamma(2, .95, .05, 5, 0.01, 30, .5, T)
elicitInvGamma(2, .95, .05, 5, 0.01, 30, .05, T)
elicitInvGamma(2, .95, .05, 5, 0.01, 30, .005, T)
library(olsrr)
?ols_step_forward_p
?ols_step_backward_p
?ols_step_both_p
?ols_step_all_possible
library(olsrr)
fullMod <- lm(mpg ~ ., data = carsdf)
knitr::include_graphics("MCP.png")
data("mtcars")
carsdf <- mtcars[,-c(8:11)]
library(leaps)
head(carsdf)
allMods <- regsubsets(mpg ~ ., data = carsdf, nbest = 10, nvmax = NULL, method = "exhaustive")
#summary(allMods)
#?plot.regsubsets
plot(allMods, scale = "Cp")
library(car)
subsets(allMods, statistic="cp", legend = FALSE, min.size = 2, main = "Mallow Cp")
abline(a = 1, b = 1, lty = 2)
library(bestglm)
## y var has to come last and be named y
carsdf.for.bestglm <- within(carsdf,
{
y    <- mpg         # mpg into
mpg  <- NULL        # Delete old mpg
})
carsdf.for.bestglm <-
carsdf.for.bestglm[, c("cyl", "disp", "hp", "drat", "wt", "qsec", "y")]
allModsWithAIC <-
bestglm(Xy = carsdf.for.bestglm,
family = gaussian,
IC = "AIC",
method = "exhaustive")
allModsWithAIC$BestModels
library(olsrr)
fullMod <- lm(mpg ~ ., data = carsdf)
ols_step_forward_p(fullMod, penter = .3, details = T)
library(olsrr)
fullMod <- lm(mpg ~ ., data = carsdf)
ols_step_backward_p(fullMod, prem = .3, details = T)
library(olsrr)
fullMod <- lm(mpg ~ ., data = carsdf)
ols_step_both_p(fullMod, pent = .1, prem = .3, details = T)
knitr::include_graphics("cv_logo.png")
library(olsrr)
fullMod <- lm(mpg ~ ., data = carsdf)
ols_step_all_possible(fullMod)
fullMod <- lm(mpg ~ ., data = carsdf)
ols_step_all_possible(fullMod)
allMods <- ols_step_all_possible(fullMod)
names(allMods)
allMods$predrsq
plot(allMods$predrsq)
plot(allMods, scale = "predrsq")
plot(allMods)
names(allMods)
allMods$predictors
allMods$predrsq
derp <- lm(mpg ~ . , data =carsdf)
names(mod)
names(derp)
lm.influence(derp0)
lm.influence(derp)
?lm.influence(derp)
lm.influence(derp)$hat
residuals(derp)/lm.influence(derp)$hat
residuals(derp)/(1-lm.influence(derp)$hat)
(residuals(derp)/(1-lm.influence(derp)$hat))^2
sum(residuals(derp)/(1-lm.influence(derp)$hat))^2
sum((carsdf$mpg - mean(carsdf$mpg))^2)
sum(residuals(derp)/(1-lm.influence(derp)$hat))^2 / sum((carsdf$mpg - mean(carsdf$mpg))^2)
1 - sum(residuals(derp)/(1-lm.influence(derp)$hat))^2 / sum((carsdf$mpg - mean(carsdf$mpg))^2)
sum(residuals(derp)/(1-lm.influence(derp)$hat))
(residuals(derp)/(1-lm.influence(derp)$hat))
(residuals(derp)/(1-lm.influence(derp)$hat))^2
sum((residuals(derp)/(1-lm.influence(derp)$hat))^2)
1 - sum(residuals(derp)/(1-lm.influence(derp)$hat))^2/sum((carsdf$mpg - mean(carsdf$mpg))^2)
sum((residuals(derp)/(1-lm.influence(derp)$hat))^2)
sum((carsdf$mpg - mean(carsdf$mpg))^2)
sum((residuals(derp)/(1-lm.influence(derp)$hat))^2) / sum((carsdf$mpg - mean(carsdf$mpg))^2)
1 - sum((residuals(derp)/(1-lm.influence(derp)$hat))^2) / sum((carsdf$mpg - mean(carsdf$mpg))^2)
1 - sum((residuals(derp)/(1-lm.influence(derp)$hat))^2) / sum((carsdf$mpg - mean(carsdf$mpg))^2)
allMods$predrsq
setwd("~/UVa/all_teaching/summer19_6021/presentations/")
library(rmarkdown)
render_site()
render_site()
