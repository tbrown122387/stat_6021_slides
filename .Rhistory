{
# alpha, beta, phi, xobs, y, m from above
# hardcoded N
N <- 10
logMissingDataProposal(c(xmis1, xmis2), alpha) + getLogImpSampEst(alpha, betas, phis, xmis1, xmis2, N)
}
plotSurface(-100, 100, -100, 100, 20, plotThis, F, theta=-120, zlab = "z", xlab = "x1", ylab = "x2")
# library(invgamma)
# library(matrixStats)
# library(MASS) # mvrnorm
# library(mvtnorm) #dmvnorm
# # library(devtools)
#devtools::install_github("tbrown122387/mmcmc")
library(mmcmc)
# library(invgamma)
# library(matrixStats)
# library(MASS) # mvrnorm
# library(mvtnorm) #dmvnorm
# # library(devtools)
devtools::install_github("tbrown122387/mmcmc")
detach(name = "package:mmcmc", unload = T)
# library(invgamma)
# library(matrixStats)
# library(MASS) # mvrnorm
# library(mvtnorm) #dmvnorm
# # library(devtools)
#devtools::install_github("tbrown122387/mmcmc")
library(mmcmc)
library(metRology) # for dtscaled
# get some data
source("~/pmglm/code/sim_fake_data.r")
numRows <- 3
betas <- c(1, -2, 3)
alpha <- 1
phis <- c(1, 1, 1)
set.seed(42)
fake_data <- sim_data(nrow = numRows, beta_coeffs = betas, alpha_coeffs = alpha, phi_coeffs = phis)
y <- fake_data$y
X <- fake_data$X
M <- fake_data$M
X[M == 0] <- NA
mis <- is.na(X)
numColsWithMiss <- sum(colSums(mis) != 0)
numMissingEachGroup <- colSums(mis)[colSums(mis) != 0]
# define prior
logPrior <- function(alpha, beta, phi){
logAlphaPrior <- invgamma::dinvgamma(alpha, shape = .001, rate = .001, log = T)
logBetaPrior <- sum(dnorm(betas, 0, 3, log = T))
logPhiPrior <- sum(dnorm(phi, 0, 3, log = T))
logAlphaPrior + logBetaPrior + logPhiPrior
}
# sample q(x_{mis} | x_{obs}, y)
#TODO edit TeX and mention how you "neutralized scale bit" and how this
# is different from curen thinking
# maybe try to seek to explain why there is a "quicksand" effect
# with this particular thing going on
propose_missdata_given_params <- function(y, alpha){
list(x2mis = rt(numMissingEachGroup, df = 10)*sqrt(alpha))
}
# eval log q(x_{mis} | x_{obs}, y)
logMissingDataProposal <- function(x2mis, alpha){
#sum(dt(x = x2mis, df = 3, log = T))
sum(dt.scaled(x = x2mis, df = 10, sd = sqrt(alpha), log = T))
}
logCondLikes <- function(xmis, beta){
# insert simulated data into missing data spots
X[is.na(X[,2])] <- xmis
X <- cbind(rep(1,numRows), X)
stopifnot(sum(is.na(X))==0)
linked_means <- as.vector(X %*% as.matrix(beta))
logLogisticRegCndtlLike(y, linked_means)
}
logMissingProbs <- function(M, xmis, phis){
X[is.na(X[,2])] <- xmis
X <- cbind(rep(1,numRows), X)
stopifnot(is.matrix(M))
stopifnot(dim(M)[1] == numRows)
stopifnot(dim(M)[2] == 2)
stopifnot(sum(is.na(X))==0)
linked_means <- as.vector(X %*% as.matrix(phis))
logLogisticRegCndtlLike(M[,2], linked_means)
}
logMissingDataProbs <- function(xmis, alpha){
sum(dnorm(xmis, 0, sd = sqrt(alpha), log = T))
}
# log p(m|y, xmis, xobs, phi) + log p(y|xmis,xobs,beta) + log p(xmis|xobs,alpha) - log q(xmis|xobs,y,alpha,beta)
getOneLogSummandWithChosenX <- function(alpha, beta, phis, y, x1, x2){
Xmis <- propose_missdata_given_params(y, alpha)
Xmis$x2mis[1] <- x1
Xmis$x2mis[2] <- x2
logLikes <- logCondLikes(Xmis$x2mis, beta)
logpmweights <- logMissingProbs(M, Xmis$x2mis, phis)
logMissXProbs <- logMissingDataProbs(Xmis$x2mis, alpha)
logQs <- logMissingDataProposal(Xmis$x2mis, alpha)
sum(logLikes+logpmweights+logMissXProbs-logQs)
}
getLogImpSampEst <- function(alphaVec, betaVec, phiVec, x1, x2, N=100){
#samps <- replicate(N, getOneLogSummandWithChosenX(alphaVec, betaVec, phiVec, y, x1, x2))
samps <- getOneLogSummandWithChosenX(alphaVec, betaVec, phiVec, y, x1, x2)
logSumExp(samps-log(N))
}
#### consrruct the plot
# hat{p}(m,y, xmis | xobs, alpha, beta, phi)
plotThis <- function(xmis1, xmis2)
{
# alpha, beta, phi, xobs, y, m from above
# hardcoded N
N <- 10
logMissingDataProposal(c(xmis1, xmis2), alpha) + getLogImpSampEst(alpha, betas, phis, xmis1, xmis2, N)
}
plotSurface(-100, 100, -100, 100, 20, plotThis, F, theta=-120, zlab = "z", xlab = "x1", ylab = "x2")
# library(invgamma)
# library(matrixStats)
# library(MASS) # mvrnorm
# library(mvtnorm) #dmvnorm
# # library(devtools)
#devtools::install_github("tbrown122387/mmcmc")
library(mmcmc)
detach("package:mmcmc", unload=T)
source('~/pmglm/code/plot_fake_data_sim_like.r')
# library(invgamma)
# library(matrixStats)
# library(MASS) # mvrnorm
# library(mvtnorm) #dmvnorm
# # library(devtools)
devtools::install_github("tbrown122387/mmcmc",force = T)
# library(invgamma)
# library(matrixStats)
# library(MASS) # mvrnorm
# library(mvtnorm) #dmvnorm
# # library(devtools)
#devtools::install_github("tbrown122387/mmcmc",force = T)
library(mmcmc)
#' @param lowerSecond lower bound of y axis
#' @param upperSecond upper bound of y axis
#' @param numGridPointsOnEachAxis how many grid points do you want on each axis
#' @param f the function that takes two scalar arguments (x and y) and produces one scalar argument (z)
#' @param contour do you want a contour plot? (True or False)
#' @param ... extra arguments to be passed to graphics::contour() or graphics::persp() (depending on what contour arg was set to)
#' @keywords plotting 3D 3-D 3d
#' @export
#' @examples
#' plotSurface(-50, 50, 0.0001, 50, 20, eval_log_unnormalized_posterior, F, theta=-120, zlab = "log unnorm dens", xlab = "mu", ylab = "ss")
plotSurface <- function(lowerFirst, upperFirst, lowerSecond, upperSecond,
numGridPointsOnEachAxis, f, contour = F, ...)
{
A <- seq(lowerFirst, upperFirst, length.out = numGridPointsOnEachAxis)
B <- seq(lowerSecond, upperSecond, length.out = numGridPointsOnEachAxis)
args <- expand.grid(A,B)
z <- mapply(f, args[,1], args[,2])
dim(z) <- c(length(A), length(B))
if(contour){
graphics::contour(A, B, z, ...)
}else{
graphics::persp(x=A, y=B, z=z, ...)
}
}
source('~/pmglm/code/plot_fake_data_sim_like.r')
# library(invgamma)
library(matrixStats)
# library(MASS) # mvrnorm
# library(mvtnorm) #dmvnorm
# # library(devtools)
#devtools::install_github("tbrown122387/mmcmc",force = T)
library(mmcmc)
library(metRology) # for dtscaled
# get some data
source("~/pmglm/code/sim_fake_data.r")
numRows <- 3
betas <- c(1, -2, 3)
alpha <- 1
phis <- c(1, 1, 1)
set.seed(42)
fake_data <- sim_data(nrow = numRows, beta_coeffs = betas, alpha_coeffs = alpha, phi_coeffs = phis)
y <- fake_data$y
X <- fake_data$X
M <- fake_data$M
X[M == 0] <- NA
mis <- is.na(X)
numColsWithMiss <- sum(colSums(mis) != 0)
numMissingEachGroup <- colSums(mis)[colSums(mis) != 0]
# define prior
logPrior <- function(alpha, beta, phi){
logAlphaPrior <- invgamma::dinvgamma(alpha, shape = .001, rate = .001, log = T)
logBetaPrior <- sum(dnorm(betas, 0, 3, log = T))
logPhiPrior <- sum(dnorm(phi, 0, 3, log = T))
logAlphaPrior + logBetaPrior + logPhiPrior
}
# sample q(x_{mis} | x_{obs}, y)
#TODO edit TeX and mention how you "neutralized scale bit" and how this
# is different from curen thinking
# maybe try to seek to explain why there is a "quicksand" effect
# with this particular thing going on
propose_missdata_given_params <- function(y, alpha){
list(x2mis = rt(numMissingEachGroup, df = 10)*sqrt(alpha))
}
# eval log q(x_{mis} | x_{obs}, y)
logMissingDataProposal <- function(x2mis, alpha){
#sum(dt(x = x2mis, df = 3, log = T))
sum(dt.scaled(x = x2mis, df = 10, sd = sqrt(alpha), log = T))
}
logCondLikes <- function(xmis, beta){
# insert simulated data into missing data spots
X[is.na(X[,2])] <- xmis
X <- cbind(rep(1,numRows), X)
stopifnot(sum(is.na(X))==0)
linked_means <- as.vector(X %*% as.matrix(beta))
logLogisticRegCndtlLike(y, linked_means)
}
logMissingProbs <- function(M, xmis, phis){
X[is.na(X[,2])] <- xmis
X <- cbind(rep(1,numRows), X)
stopifnot(is.matrix(M))
stopifnot(dim(M)[1] == numRows)
stopifnot(dim(M)[2] == 2)
stopifnot(sum(is.na(X))==0)
linked_means <- as.vector(X %*% as.matrix(phis))
logLogisticRegCndtlLike(M[,2], linked_means)
}
logMissingDataProbs <- function(xmis, alpha){
sum(dnorm(xmis, 0, sd = sqrt(alpha), log = T))
}
# log p(m|y, xmis, xobs, phi) + log p(y|xmis,xobs,beta) + log p(xmis|xobs,alpha) - log q(xmis|xobs,y,alpha,beta)
getOneLogSummandWithChosenX <- function(alpha, beta, phis, y, x1, x2){
Xmis <- propose_missdata_given_params(y, alpha)
Xmis$x2mis[1] <- x1
Xmis$x2mis[2] <- x2
logLikes <- logCondLikes(Xmis$x2mis, beta)
logpmweights <- logMissingProbs(M, Xmis$x2mis, phis)
logMissXProbs <- logMissingDataProbs(Xmis$x2mis, alpha)
logQs <- logMissingDataProposal(Xmis$x2mis, alpha)
sum(logLikes+logpmweights+logMissXProbs-logQs)
}
getLogImpSampEst <- function(alphaVec, betaVec, phiVec, x1, x2, N=100){
#samps <- replicate(N, getOneLogSummandWithChosenX(alphaVec, betaVec, phiVec, y, x1, x2))
samps <- getOneLogSummandWithChosenX(alphaVec, betaVec, phiVec, y, x1, x2)
matrixStats::logSumExp(samps-log(N))
}
#### consrruct the plot
# hat{p}(m,y, xmis | xobs, alpha, beta, phi)
plotThis <- function(xmis1, xmis2)
{
# alpha, beta, phi, xobs, y, m from above
# hardcoded N
N <- 10
logMissingDataProposal(c(xmis1, xmis2), alpha) + getLogImpSampEst(alpha, betas, phis, xmis1, xmis2, N)
}
plotSurface(-100, 100, -100, 100, 20, plotThis, F, theta=-120, zlab = "z", xlab = "x1", ylab = "x2")
y
y <- c(0,0,0)
# define prior
logPrior <- function(alpha, beta, phi){
logAlphaPrior <- invgamma::dinvgamma(alpha, shape = .001, rate = .001, log = T)
logBetaPrior <- sum(dnorm(betas, 0, 3, log = T))
logPhiPrior <- sum(dnorm(phi, 0, 3, log = T))
logAlphaPrior + logBetaPrior + logPhiPrior
}
# sample q(x_{mis} | x_{obs}, y)
#TODO edit TeX and mention how you "neutralized scale bit" and how this
# is different from curen thinking
# maybe try to seek to explain why there is a "quicksand" effect
# with this particular thing going on
propose_missdata_given_params <- function(y, alpha){
list(x2mis = rt(numMissingEachGroup, df = 10)*sqrt(alpha))
}
# eval log q(x_{mis} | x_{obs}, y)
logMissingDataProposal <- function(x2mis, alpha){
#sum(dt(x = x2mis, df = 3, log = T))
sum(dt.scaled(x = x2mis, df = 10, sd = sqrt(alpha), log = T))
}
logCondLikes <- function(xmis, beta){
# insert simulated data into missing data spots
X[is.na(X[,2])] <- xmis
X <- cbind(rep(1,numRows), X)
stopifnot(sum(is.na(X))==0)
linked_means <- as.vector(X %*% as.matrix(beta))
logLogisticRegCndtlLike(y, linked_means)
}
logMissingProbs <- function(M, xmis, phis){
X[is.na(X[,2])] <- xmis
X <- cbind(rep(1,numRows), X)
stopifnot(is.matrix(M))
stopifnot(dim(M)[1] == numRows)
stopifnot(dim(M)[2] == 2)
stopifnot(sum(is.na(X))==0)
linked_means <- as.vector(X %*% as.matrix(phis))
logLogisticRegCndtlLike(M[,2], linked_means)
}
logMissingDataProbs <- function(xmis, alpha){
sum(dnorm(xmis, 0, sd = sqrt(alpha), log = T))
}
# log p(m|y, xmis, xobs, phi) + log p(y|xmis,xobs,beta) + log p(xmis|xobs,alpha) - log q(xmis|xobs,y,alpha,beta)
getOneLogSummandWithChosenX <- function(alpha, beta, phis, y, x1, x2){
Xmis <- propose_missdata_given_params(y, alpha)
Xmis$x2mis[1] <- x1
Xmis$x2mis[2] <- x2
logLikes <- logCondLikes(Xmis$x2mis, beta)
logpmweights <- logMissingProbs(M, Xmis$x2mis, phis)
logMissXProbs <- logMissingDataProbs(Xmis$x2mis, alpha)
logQs <- logMissingDataProposal(Xmis$x2mis, alpha)
sum(logLikes+logpmweights+logMissXProbs-logQs)
}
getLogImpSampEst <- function(alphaVec, betaVec, phiVec, x1, x2, N=100){
#samps <- replicate(N, getOneLogSummandWithChosenX(alphaVec, betaVec, phiVec, y, x1, x2))
samps <- getOneLogSummandWithChosenX(alphaVec, betaVec, phiVec, y, x1, x2)
matrixStats::logSumExp(samps-log(N))
}
#### consrruct the plot
# hat{p}(m,y, xmis | xobs, alpha, beta, phi)
plotThis <- function(xmis1, xmis2)
{
# alpha, beta, phi, xobs, y, m from above
# hardcoded N
N <- 10
logMissingDataProposal(c(xmis1, xmis2), alpha) + getLogImpSampEst(alpha, betas, phis, xmis1, xmis2, N)
}
plotSurface(-100, 100, -100, 100, 20, plotThis, F, theta=-120, zlab = "z", xlab = "x1", ylab = "x2")
betas
# sample q(x_{mis} | x_{obs}, y)
#TODO edit TeX and mention how you "neutralized scale bit" and how this
# is different from curen thinking
# maybe try to seek to explain why there is a "quicksand" effect
# with this particular thing going on
propose_missdata_given_params <- function(y, alpha){
list(x2mis = rt(numMissingEachGroup, df = 3))
#list(x2mis = rt(numMissingEachGroup, df = 10)*sqrt(alpha))
}
# eval log q(x_{mis} | x_{obs}, y)
logMissingDataProposal <- function(x2mis, alpha){
sum(dt(x = x2mis, df = 3, log = T))
#sum(dt.scaled(x = x2mis, df = 10, sd = sqrt(alpha), log = T))
}
logCondLikes <- function(xmis, beta){
# insert simulated data into missing data spots
X[is.na(X[,2])] <- xmis
X <- cbind(rep(1,numRows), X)
stopifnot(sum(is.na(X))==0)
linked_means <- as.vector(X %*% as.matrix(beta))
logLogisticRegCndtlLike(y, linked_means)
}
logMissingProbs <- function(M, xmis, phis){
X[is.na(X[,2])] <- xmis
X <- cbind(rep(1,numRows), X)
stopifnot(is.matrix(M))
stopifnot(dim(M)[1] == numRows)
stopifnot(dim(M)[2] == 2)
stopifnot(sum(is.na(X))==0)
linked_means <- as.vector(X %*% as.matrix(phis))
logLogisticRegCndtlLike(M[,2], linked_means)
}
logMissingDataProbs <- function(xmis, alpha){
sum(dnorm(xmis, 0, sd = sqrt(alpha), log = T))
}
# log p(m|y, xmis, xobs, phi) + log p(y|xmis,xobs,beta) + log p(xmis|xobs,alpha) - log q(xmis|xobs,y,alpha,beta)
getOneLogSummandWithChosenX <- function(alpha, beta, phis, y, x1, x2){
Xmis <- propose_missdata_given_params(y, alpha)
Xmis$x2mis[1] <- x1
Xmis$x2mis[2] <- x2
logLikes <- logCondLikes(Xmis$x2mis, beta)
logpmweights <- logMissingProbs(M, Xmis$x2mis, phis)
logMissXProbs <- logMissingDataProbs(Xmis$x2mis, alpha)
logQs <- logMissingDataProposal(Xmis$x2mis, alpha)
sum(logLikes+logpmweights+logMissXProbs-logQs)
}
getLogImpSampEst <- function(alphaVec, betaVec, phiVec, x1, x2, N=100){
#samps <- replicate(N, getOneLogSummandWithChosenX(alphaVec, betaVec, phiVec, y, x1, x2))
samps <- getOneLogSummandWithChosenX(alphaVec, betaVec, phiVec, y, x1, x2)
matrixStats::logSumExp(samps-log(N))
}
#### consrruct the plot
# hat{p}(m,y, xmis | xobs, alpha, beta, phi)
plotThis <- function(xmis1, xmis2)
{
# alpha, beta, phi, xobs, y, m from above
# hardcoded N
N <- 10
logMissingDataProposal(c(xmis1, xmis2), alpha) + getLogImpSampEst(alpha, betas, phis, xmis1, xmis2, N)
}
plotSurface(-100, 100, -100, 100, 20, plotThis, F, theta=-120, zlab = "z", xlab = "x1", ylab = "x2")
source('~/pmglm/code/plot_fake_data_sim_like.r')
source('~/pmglm/code/plot_fake_data_sim_like.r')
source('~/pmglm/code/plot_fake_data_sim_like.r')
source('~/pmglm/code/plot_fake_data_sim_like.r')
y
numMissingEachGroup
numColsWithMiss <- sum(colSums(mis) != 0)
M
source('~/pmglm/code/plot_fake_data_sim_like.r')
source('~/pmglm/code/plot_fake_data_sim_like.r')
numMissingEachGroup
numRows <- 4
betas <- c(1, -2, 3)
alpha <- 10.1
phis <- c(1, 1, 1)
source('~/pmglm/code/plot_fake_data_sim_like.r')
source('~/pmglm/code/plot_fake_data_sim_like.r')
source('~/pmglm/code/plot_fake_data_sim_like.r')
source('~/pmglm/code/plot_fake_data_sim_like.r')
?persp
plotThis(0,0)
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2",
zlim = c(-100,-10))
plotThis(0,0)
plotThis(-100,-100)
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2",
zlim = c(-500,-10))
plotThis(-1000,-1000)
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2",
zlim = c(-11000,-10))
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2",
zlim = c(-15000,-10))
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2",
zlim = c(-14000,-10))
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2",
zlim = c(-20000,-10))
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2",
zlim = c(-18000,-10))
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2",
zlim = c(-15000,-10))
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2",
zlim = c(-16000,-10))
source('~/pmglm/code/plot_fake_data_sim_like.r')
source('~/pmglm/code/plot_fake_data_sim_like.r')
#' @param lowerSecond lower bound of y axis
#' @param upperSecond upper bound of y axis
#' @param numGridPointsOnEachAxis how many grid points do you want on each axis
#' @param f the function that takes two scalar arguments (x and y) and produces one scalar argument (z)
#' @param contour do you want a contour plot? (True or False)
#' @param ... extra arguments to be passed to graphics::contour() or graphics::persp() (depending on what contour arg was set to)
#' @keywords plotting 3D 3-D 3d
#' @export
#' @examples
#' plotSurface(-50, 50, 0.0001, 50, 20, eval_log_unnormalized_posterior, F, theta=-120, zlab = "log unnorm dens", xlab = "mu", ylab = "ss")
plotSurface <- function(lowerFirst, upperFirst, lowerSecond, upperSecond,
numGridPointsOnEachAxis, f, contour = F, ...)
{
A <- seq(lowerFirst, upperFirst, length.out = numGridPointsOnEachAxis)
B <- seq(lowerSecond, upperSecond, length.out = numGridPointsOnEachAxis)
args <- expand.grid(A,B)
z <- mapply(f, args[,1], args[,2])
dim(z) <- c(length(A), length(B))
if(contour){
graphics::contour(A, B, z, ...)
}else{
graphics::persp(x=A, y=B, z=z, ...)
}
}
source('~/pmglm/code/plot_fake_data_sim_like.r')
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2",
zlim = c(0,10))
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2")
source('~/pmglm/code/plot_fake_data_sim_like.r')
source('~/pmglm/code/plot_fake_data_sim_like.r')
plotThis(1,1)
plotThis(-100,-100)
plotThis(0,0)
#### consrruct the plot
# hat{p}(m,y, xmis | xobs, alpha, beta, phi)
plotThis <- function(xmis1, xmis2)
{
# alpha, beta, phi, xobs, y, m from above
# hardcoded N
N <- 1
logMissingDataProposal(c(xmis1, xmis2), alpha) + getLogImpSampEst(alpha, betas, phis, xmis1, xmis2, N)
}
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2")
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2",
zlim = c(-15000,-15))
source('~/pmglm/code/plot_fake_data_sim_like.r')
plotThis(-1000,-1000)
plotThis(0,0)
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2",
zlim = c(-15000,0))
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2",
zlim = c(-150000,0))
plotSurface(-1000, 1000, -1000, 1000, 30,
plotThis, F, theta=-120,
zlab = "z", xlab = "x1", ylab = "x2",
zlim = c(-1500000,0))
setwd("~/UVa/all_teaching/summer19_6021/presentations/")
library(rmarkdown)
render_site()
